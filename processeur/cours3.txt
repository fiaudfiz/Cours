üìù Module 3 : Les Al√©as du Pipeline (Pipeline Hazards)
1. Les Concepts Cl√©s

    Pipeline : L'autoroute du CPU. Technique qui permet de lancer une instruction avant que la pr√©c√©dente ne soit finie (parall√©lisme au niveau des instructions).

    Stall (ou "Bulle") : Quand le pipeline doit se mettre en pause. C'est un cycle perdu o√π le CPU ne produit rien.

2. Les 3 Types d'Al√©as (Les Ennemis)
A. L'Al√©a Structurel (Resource Hazard)

    C'est quoi ? Une "bagarre" de mat√©riel. Deux instructions essaient d'utiliser le m√™me morceau du processeur au m√™me moment (ex: une instruction veut √™tre lue en m√©moire pendant qu'une autre veut √©crire une donn√©e en m√©moire).

    Solution Hardware : Architecture de Harvard (modifi√©e).

        On s√©pare physiquement les caches : L1 Instruction (pour le code) et L1 Data (pour les variables). Comme √ßa, on peut charger du code et lire une variable en m√™me temps sans bouchon.

B. L'Al√©a de Donn√©es (Data Hazard) - Le plus courant

    C'est quoi ? Une d√©pendance. L'instruction B a besoin du r√©sultat de l'instruction A, mais A n'a pas encore fini de calculer.

        Exemple : int a = 1 + 1; int b = a * 2; (B doit attendre que A ait √©crit la valeur de a).

    Cons√©quence : Le CPU doit ins√©rer des Bulles (Stalls). Il g√®le l'instruction B pendant 1 ou 2 cycles le temps que A finisse.

C. L'Al√©a de Contr√¥le (Control Hazard) - Le plus co√ªteux

    C'est quoi ? L'incertitude du if. Le CPU charge les instructions √† la suite, mais face √† un saut (conditionnel if ou inconditionnel goto), il ne sait pas o√π aller tant que la condition n'est pas calcul√©e.

    Le M√©canisme : Le Branch Predictor (le parieur). Il devine le chemin et continue d'ex√©cuter de mani√®re sp√©culative.

    Cons√©quence (Si erreur) : Le Pipeline Flush.

        Le CPU doit jeter √† la poubelle toutes les instructions charg√©es par erreur. C'est une perte √©norme de cycles (p√©nalit√© de mauvaise pr√©diction).

3. Les Super-Solutions (Comment on supprime les Stalls)
A. Le Forwarding (ou Bypassing)

    Pour quel probl√®me ? L'Al√©a de Donn√©es.

    Le principe : Au lieu d'attendre que le r√©sultat soit √©crit officiellement dans le registre (√©tape Write-Back, √† la fin), on le r√©cup√®re d√®s qu'il sort de la calculatrice (ALU).

    Le terme technique pour le "c√¢ble" : Cela s'appelle un Multiplexeur de Forwarding (ou Forwarding Unit). Il court-circuite le chemin normal pour relier directement la sortie de l'√©tage EX (Execute) de l'instruction A vers l'entr√©e de l'√©tage EX de l'instruction B.

B. L'Ex√©cution dans le D√©sordre (Out-of-Order Execution - OoO)

    Pour quel probl√®me ? Tous les blocages qui durent longtemps (ex: attendre la RAM).

    Le principe : Le CPU poss√®de une "fen√™tre d'instructions". Si l'instruction actuelle est bloqu√©e, il regarde plus loin dans le code pour trouver des instructions ind√©pendantes (qui n'ont pas besoin des r√©sultats en attente) et les ex√©cute tout de suite.

    Analogie : √Ä la caisse du supermarch√©, si le client devant toi a oubli√© de peser ses bananes, la caissi√®re ne s'arr√™te pas : elle scanne les articles du client suivant en attendant.