üß† COURS COMPLET : LES LISTES CHA√éN√âES (Linked Lists)
1. La Philosophie : Pourquoi √ßa existe ?

En informatique, pour stocker une suite de donn√©es, on a deux grandes strat√©gies :

    L'approche "H√¥tel" (Tableau) : On r√©serve 10 chambres d'un coup. Elles sont toutes coll√©es. C'est pratique pour appeler la chambre n¬∞5, mais si on veut une 11√®me chambre et que l'h√¥tel est plein √† c√¥t√©, on doit d√©m√©nager tout le monde ailleurs.

    L'approche "Jeu de piste" (Liste Cha√Æn√©e) : Chaque personne a une chambre n'importe o√π dans la ville. Mais chaque personne a un papier avec l'adresse de la personne suivante. Pour trouver la 5√®me personne, il faut forc√©ment passer par la 1, puis la 2, la 3...

2. Anatomie d'un N≈ìud (Node)

Un n≈ìud est l'unit√© de base. En m√©moire, il se compose de deux parties distinctes :

    Le Champ de Donn√©e (Data) : La valeur utile (un entier, un flottant, une structure client...).

    Le Pointeur (Next) : Une variable qui stocke l'adresse m√©moire du n≈ìud suivant.

Le concept de "La T√™te" (Head) : C'est ton seul point d'entr√©e. C'est un pointeur qui pointe vers le premier n≈ìud. Si tu perds la t√™te, tu perds tout le reste de la cha√Æne (car personne ne sait o√π elle commence).
3. Analyse de Performance : Le duel face au Tableau

C'est ici que se jouent tes points en examen. Il faut comprendre la complexit√© algorithmique (O notation).
A. L'acc√®s aux donn√©es (Le "Lookup")

    Tableau : O(1). C'est instantan√©. L'ordinateur calcule l'adresse via : adresse_debut + (index * taille_type).

    Liste : O(n). Si tu cherches le 100√®me √©l√©ment, tu DOIS parcourir les 99 pr√©c√©dents. C'est le gros point faible de la liste.

B. L'insertion et la suppression

    Tableau : O(n). Si tu veux ins√©rer un chiffre au d√©but d'un tableau de 1000 cases, tu dois d√©caler les 1000 √©l√©ments d'une case vers la droite. C'est lourd.

    Liste : O(1).

        Tu cr√©es ton n≈ìud.

        Tu branches son "Next" sur la suite.

        Tu branches le "Next" du pr√©c√©dent sur ton nouveau n≈ìud. Rien ne bouge en m√©moire, on change juste des fils √©lectriques.

4. Les diff√©rentes familles de listes
1. La Liste Simplement Cha√Æn√©e (Singly Linked)

C'est la plus basique. On ne peut aller que vers l'avant. Si tu es au n≈ìud 3, tu ne peux pas revenir au 2 sans recommencer depuis le d√©but.
2. La Liste Doublement Cha√Æn√©e (Doubly Linked)

Chaque n≈ìud a deux pointeurs : next (suivant) et prev (pr√©c√©dent).

    Avantage : On peut naviguer dans les deux sens et supprimer un n≈ìud plus facilement.

    Inconv√©nient : √áa consomme plus de m√©moire (un pointeur en plus par n≈ìud).

3. La Liste Circulaire

Le dernier n≈ìud, au lieu de pointer vers NULL, pointe vers la Head.

    Usage : Id√©al pour les syst√®mes qui tournent en boucle (ex: un lecteur de musique qui r√©p√®te une playlist, ou le temps de parole d'un processeur partag√© entre plusieurs applis).

5. Gestion de la M√©moire (Le point critique en C)

C'est l√† que les d√©butants font des erreurs. Contrairement aux tableaux d√©clar√©s comme int tab[10] (m√©moire automatique), les listes utilisent la m√©moire dynamique.

    Allocation : On utilise malloc. Cela r√©serve une place dans le Tas (Heap). Cette m√©moire ne dispara√Æt jamais toute seule.

    Lib√©ration : Quand on supprime un √©l√©ment, il faut faire un free(). Si tu ne le fais pas, ton programme consomme de plus en plus de RAM jusqu'au plantage : c'est la fuite m√©moire (Memory Leak).

    Le Segfault : C'est l'erreur n¬∞1. Elle arrive quand tu essaies d'acc√©der √† node->next alors que node est d√©j√† NULL.

6. R√©sum√© pour ton cerveau
Si ton besoin est...	Utilise...
Lire souvent des donn√©es au hasard	Tableau
Ajouter/Supprimer tout le temps des √©l√©ments	Liste Cha√Æn√©e
Ne pas savoir √† l'avance combien d'objets tu auras	Liste Cha√Æn√©e
√âconomiser la m√©moire au maximum	Tableau (pas de pointeurs next)