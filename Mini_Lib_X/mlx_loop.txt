MLX_LOOP()

Apres avoir une fenetre qui s'affiche, le programme va continuer.... et s'arreter.
mlx_loop cest une un e boucle infinie qui maintient ton programme en vie et qui ecoute tout ce qui se passe: touches clavier, clics souris etc.

mlx_new_window() -> fenetre visible
mlx_loop() -> programme vivant, ecoute et dispatche les events.

c'est un appel bloquant : rien apres ceci dans un code ne s'executera tant que la boucle tourne.

La fonction mlx_loop() en 3 etapes:

    -prepare la bouble mlx_int_set_win_event_mask() applique les masques d'events sur les fenetres.
        Puis do flush passe a 0 et c'est Xsync qui gere la synchro avec le serveur X11, plus besoin de flush manuel.
    -ecoute et dispatche les events X11.XNextEventm recupere le prochain event de la file X11, trouve a quelle fenetre il appartient puis appel le hook correspondant avec mlx_hook()
    -Appele loop_hook() a chaque tour: apres avoir vide la file d'events, XSync synchronise avec le serveur X11.

Cas particulier :
    la croix n'est pas un event classique.C'est un ClientMessage envoye par le window manager,
        la boucle detecte manuellement en verifiant l'atome WM_DELETE_WINDOW prepare dans mlx_init.
        Pour que la croix fonctionne on doit brancher le hook a l'event.

2 modes de fonctionnement :

    le comportement de la boucle change completement selon que on a un mlx_hook ou non.
    sans loop_hook : XNextEvent bloque jusqu'au prochain event le programme "dort" -> mode statique, pour un programme qui ne fait rien tant que on agit pas
    avec loop_hook : le programme tourne en continu c'est le mode pour les animations et le rendu en temps reel.


Comment arreter la boucle  = mlx_loop_end()

    la seul facon se stopper la boucle depuis un hook.Elle met le flag end_loop a 1
    et le while externe s'arrete au tour suivant.La boucle s'arrete naturellement si toutes les fenetres ont ete detruites.

Valeur de retour :
    elle return un 0 quand la boucle se termine proprement.On s'en sert rarement.
    
